<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Introduction to Functional Programming</title>

	<link rel="stylesheet" href="css/reset.css">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<style type="text/css">
		.reveal .title td {
			vertical-align: middle;
			width: 50%;
		}

		.twocolumn {
			display: grid;
			grid-template-columns: 50% 50%;
			grid-gap: 10px;
			text-align: left;
		}

		.twocolumn pre {
			display: inline-block;
			font-size: 0.33em;
			width: 100%;
		}

		.reveal section img.transparent {
			background: none;
		}

		.reveal blockquote p::before {
			content: "“";
		}

		.reveal blockquote p::after {
			content: '”';
		}
	</style>

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/vs2015.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-transition="slide none">
				<table class="title">
					<tr>
						<td>
							<h3>
								Introduction to Functional Programming
							</h3>
						</td>
						<td>
							<img src="https://imgs.xkcd.com/comics/functional_2x.png" alt="Functional">
						</td>
					</tr>
				</table>
			</section>
			<section data-transition="none">
				<table class="title">
					<tr>
						<td>
							<p>Agenda:</p>
							<ol>
								<li>What is functional programming</li>
								<li>From imperative to declarative - a concrete example</li>
								<li>Thinking Functionally</li>
								<li>Pure functions and immutable data</li>
							</ol>
						</td>
						<td>
							<img src="https://imgs.xkcd.com/comics/functional_2x.png" alt="Functional">
						</td>
					</tr>
				</table>
			</section>
			<section data-transition="convex">
				<h3>What is functional programming</h3>
				<section>
					<blockquote>
						<p>If you ask two functional programmers what FP is, you’ll get (at least) three different answers</p>
					</blockquote>
				</section>
				<section>
					<blockquote>
						<p>Functional programming is a style of programming that emphasizes the evaluation of expressions,
							rather than execution of commands.<br />
							The expressions in these languages are formed by using functions to combine basic values.</p>
						<footer style="text-align: left; font-style: normal; color: gray">--FAQ for comp.lang.functional</footer>
					</blockquote>
				</section>
				<section>
					<ul>
						<li class="fragment">Avoiding State
							<ul>
								<li>Strive for pure functions</li>
								<li>Prefer immutable data</li>
							</ul>
						</li>
						<li class="fragment">Functions as first-class entities</li>
						<li class="fragment">Declerative programming
							<ul>
								<li>Imperative: how to do something</li>
								<li>Declarative: what should be done</li>
							</ul>
						</li>
					</ul>
					<aside class="notes">
						Some of the highlights of FP are:
					</aside>
				</section>
			</section>
			<section data-transition="convex">A concrete example</section>
			<section data-transition="convex">
				<h3>Line count</h3>
				<section>
					<blockquote>Given a list of files, calculate the number of lines in each file</blockquote>
				</section>
				<section>
					<ol>
						<li class="fragment">Open each file</li>
						<li class="fragment">Define a counter to store the number of lines</li>
						<li class="fragment">
							Read the file one character at a time, and increase the counter every time the newline
							character (<code>/n</code>) occurs
						</li>
						<li class="fragment">At the end of a file, store the number of lines calculated</li>
					</ol>
					<aside class="notes">
						We might solve this problem in the following way:
					</aside>
				</section>
				<section data-transition="slice none">
					<pre>
						<code class="stretch" data-line-numbers="" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
					<aside class="notes">
						This is the algorithm in code.
						Let's go through this
					</aside>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="1-4,18" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="5" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="6,16" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="7-8" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="9-14" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="15" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code class="stretch" data-line-numbers="17" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code class="stretch" data-line-numbers="" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;
								for (const auto& file : files) {
									int line_count = 0;
									std::ifstream in(file);
									char c = 0;
									while (in.get(c)) {
										if (c == '\n') {
											line_count++;
										}
									}
									results.push_back(line_count);
								}
								return results;
							}
						</code>
					</pre>
					<aside class="notes">
						two nested loops and a few variables to keep the current state of the process.
						counting occurences of an element in a sequence is a recurring pattern and most
						languages have abstractions for it and C++ is no different.
					</aside>
				</section>
				<section>
					<pre>
						<code class="hljs" data-line-numbers="1-9, 18" data-trim>
							int count_lines(const std::string& filename)
							{
								std::ifstream in(filename);

								return std::count(
									std::istreambuf_iterator&lt;char&gt;(in),
									std::istreambuf_iterator&lt;char&gt;(),
									'\n');
							}
						</code>
					</pre>

					<aside class="notes">
						With this solution, you’re no longer concerned about exactly how the counting is implemented;
						you’re just <strong>declaring</strong> that you want to count the number of newlines that appear in the
						given input stream.
						This is always the main idea when writing programs in the functional style—use abstractions
						that let you define the <strong>intent instead of specifying how</strong> to do something.<br>
						we can use this function as follows:
					</aside>
				</section>
				<section data-transition="slide none">
					<pre>
						<code class="stretch" data-line-numbers="8" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results;

								for (const auto& file : files) {
									results.push_back(count_lines(file));
								}

								return results;
							}
						</code>
					</pre>

					<aside class="notes">
						We're left with a range-based for loop that applies a function to all elements in a collection and collects
						the results.
						<strong>again</strong> this is a common pattern which is C++ is expressed by
						<strong><code>std::transform</code></strong>
						algorithm (called map on other languages)
					</aside>
				</section>
				<section data-transition="none none">
					<pre>
						<code class="stretch" data-line-numbers="5-9" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								std::vector&lt;int&gt; results(files.size());

								std::transform(files.begin(), files.end(), 
									results.begin(),
									count_lines);

								return results;
							}
						</code>
					</pre>

					<aside class="notes">
						This code no longer specifies the algorithm steps that need to be taken,
						but rather how the input should be transformed in order to get the desired output
					</aside>
				</section>
				<section data-transition="none slide">
					<pre>
						<code class="stretch" data-line-numbers  data-trim data-noescape>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& <mark>files</mark>)
							{
								std::vector&lt;int&gt; results(files.size());

								std::<mark>transform</mark>(files.begin(), files.end(), 
									results.begin(),
									<mark>count_lines</mark>);

								return results;
							}
						</code>
					</pre>

					<aside class="notes">
						The problem is that the listing includes too much boilerplate code to be considered more readable than the
						original example.
						The boilerplate can be reduced to minimum with the new ranges library from C++20.
					</aside>
				</section>
				<section>
					<pre>
						<code class="stretch" data-line-numbers="6" data-trim>
							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files)
							{
								using std::ranges::transform;
								return files | transform(count_lines);
							}
						</code>
					</pre>
				</section>
				<section>
					<pre>
						<code data-trim style="text-align: center">
							int count_lines(const std::string&);
						</code>
					</pre>

					<aside class="notes">
						if you wouldn't be familiar with this function what would you think it would do?
						it's better to split it to two functions:
					</aside>
				</section>
				<section>
					<pre>
						<code data-trim style="text-align: center">
							std::ifstream open_file(const std::string&);
						</code>
						<code data-trim style="text-align: center">
							int count_lines(std::ifstream);
						</code>
					</pre>

					<aside class="notes">
						this makes the final declarative program to be:
					</aside>
				</section>
				<section>
					<pre>
						<code class="stretch" data-trim data-line-numbers="1, 5, 16-17">
							std::ifstream open_file(const std::string& filename){
								return {filename};
							}

							int count_lines(std::fstream file) {
								return ranges::count(
									std::istreambuf_iterator&lt;char&gt;(file),
									std::istreambuf_iterator&lt;char&gt;(),
									'\n');
							}

							std::vector&lt;int&gt;
							count_lines_in_files
							(const std::vector&lt;std::string&gt;& files) {
								using std::ranges::transform;
								return files | transform(open_file)
								             | transform(count_lines);
							}
						</code>
					</pre>

					<aside class="notes">
						let's compare the two solutions:
					</aside>
				</section>
				<section data-transition="slide none">
					<div class="twocolumn">
						<div>
							<p style="text-align: center">Imperative</p>
							<pre>
										<code data-trim data-line-numbers>
												std::vector&lt;int&gt;
												count_lines_in_files
												(const std::vector&lt;std::string&gt;& files)
												{
													std::vector&lt;int&gt; results;
													for (const auto& file : files) {
														int line_count = 0;
														std::ifstream in(file);
														char c = 0;
														while (in.get(c)) {
															if (c == '\n') {
																line_count++;
															}
														}
														results.push_back(line_count);
													}
													return results;
												}
										</code>
									</pre>
						</div>
						<div>
							<p style="text-align: center">Declarative</p>
							<pre>
									<code data-trim data-line-numbers>
										std::ifstream open_file(const std::string& filename){
											return {filename};
										}

										int count_lines(std::fstream file) {
											return ranges::count(
												std::istreambuf_iterator&lt;char&gt;(file),
												std::istreambuf_iterator&lt;char&gt;(),
												'\n');
										}

										std::vector&lt;int&gt;
										count_lines_in_files
										(const std::vector&lt;std::string&gt;& files) {
											using std::ranges::transform;
											return files | transform(open_file)
											             | transform(count_lines);
										}
									</code>
								</pre>
						</div>
					</div>
				</section>
				<section data-transition="none slide">
					<div class="twocolumn">
						<div>
							<p style="text-align: center">Imperative</p>
							<pre>
										<code data-trim data-line-numbers="5, 7-9">
												std::vector&lt;int&gt;
												count_lines_in_files
												(const std::vector&lt;std::string&gt;& files)
												{
													std::vector&lt;int&gt; results;
													for (const auto& file : files) {
														int line_count = 0;
														std::ifstream in(file);
														char c = 0;
														while (in.get(c)) {
															if (c == '\n') {
																line_count++;
															}
														}
														results.push_back(line_count);
													}
													return results;
												}
										</code>
									</pre>
						</div>
						<div>
							<p style="text-align: center">Declarative</p>
							<pre>
									<code data-trim data-line-numbers="-1">
										std::ifstream open_file(const std::string& filename){
											return {filename};
										}

										int count_lines(std::fstream file) {
											return ranges::count(
												std::istreambuf_iterator&lt;char&gt;(file),
												std::istreambuf_iterator&lt;char&gt;(),
												'\n');
										}

										std::vector&lt;int&gt;
										count_lines_in_files
										(const std::vector&lt;std::string&gt;& files) {
											using std::ranges::transform;
											return files | transform(open_file)
											             | transform(count_lines);
										}
									</code>
								</pre>
						</div>
					</div>
				</section>
			</section>
			<section data-transition="convex">
				Thinking functionally

				<aside class="notes">
					It would be inefficient and counterproductive to write code in the imperative style first
					and then change it bit by bit until it became functional.
					Instead, you should think about problems differently.
					Instead of thinking of the algorithm steps,
					you should consider what the input is, what the output is,
					and which transformations you should perform to map one to the other
					Let's go back to the previous example:
				</aside>
			</section>
			<section data-transition="convex">
				<h3>Thinking functionally</h3>
				<section data-transition="slide fade">
					<img data-src="lib/resources/thinking0.png" alt="the problem" class="plain transparent">

					<aside class="notes">
						how do we transform the input data to get the desired result ?
						we can simplify the problem by analyzing the needed transformation
						only for a single item from the given collection
					</aside>
				</section>
				<section data-transition="fade">
					<img data-src="lib/resources/thinking1.png" alt="simplifed to single element" class="plain transparent">

					<aside class="notes">
						it’s clear that you’re given <em>filename</em> but we need the <em>file contents</em> with which
						we can count the number of lines
					</aside>
				</section>
				<section data-transition="fade none">
					<img data-src="lib/resources/thinking2.png" alt="solution of single element" class="plain transparent">

					<aside class="notes">
						You can <stroing>decompose</stroing> a bigger problem of counting the number of lines in a file
						whose name you have into two smaller problems.
						Now we can <strong>lift</strong> these two functions to be able to work not just on a single value,
						but on a collection of values
					</aside>
				</section>
				<section data-transition="none">
					<img data-src="lib/resources/thinking3.png" alt="lifting the solution" class="plain transparent">
				</section>
			</section>
			<section data-transition="convex">Pure functions and immutable data</section>
			<section data-transition="convex slide">
				<h3>Pure functions and immutable data</h3>
				<section>
					<h6>Definition of a pure function:</h6>
					<ul>
						<li>Output depends only on input</li>
						<li>No side effects</li>
					</ul>
				</section>
				<section>
					<h6>Pure functions are easier to:</h6>
					<ul>
						<li class="fragment">reason about</li>
						<li class="fragment">combine</li>
						<li class="fragment">test</li>
						<li class="fragment">debug</li>
						<li class="fragment">parallelize</li>
					</ul>

					<aside class="notes">
						<ul>
							<li>you can get a terrific idea of what it does just by looking at its signature</li>
							<li>Because “output depends only on input”</li>
							<li>because you don’t have to worry about them dealing with hidden state and side effects</li>
							<li>you don’t need to look outside the function’s scope to debug it</li>
							<li>the compiler is free to change order or parallelize pure functions becuase the lack of side effects
							</li>
						</ul>
					</aside>
				</section>
			</section>
			<section data-transition="none slide">
				<h3>Pure functions and immutable data</h3>
				<h5>Pure or not?</h5>
				<section>
					<aside class="notes">
						Let's play a game in which you tell if a function is pure or not:
					</aside>
				</section>
				<section data-transition="slide none">
					<pre>
						<code data-trim class="cpp" data-noescape>
							<span class="fragment">// pure</span>
							int sum(int a, int b) {
								return a + b;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code data-trim data-noescape class="cpp">
							<span class="fragment">// impure - output depends on external value</span>
							int a;
							int getA() {
								return a;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code data-trim data-noescape class="cpp">
							<span class="fragment">// impure - side effect</span>
							int count() {
								static int x = 0;
								++x;
								return x;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code data-trim data-noescape class="cpp">
							<span class="fragment">// impure - side effect</span>
							void hello() {
								std::cout &lt;&lt; "Hello, world!\n" &lt;&lt;;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code data-trim data-noescape class="cpp">
							<span class="fragment">// impure - side effect</span>
							void inc(int &x) {
								x += 1;
							}
						</code>
					</pre>
				</section>
				<section data-transition="none">
					<pre>
						<code data-trim data-noescape class="cpp">
							<span class="fragment">// pure</span>
							auto getInc() {
								return [](int &x) {
									x += 1;
								};
							}
						</code>
					</pre>
				</section>
			</section>
			<section>
				<h3>Pure functions and immutable data</h3>
				<section>
					<h6>Advantages of immutable data:</h6>
					<ul>
						<li>Encourages writing side-effect free functions</li>
						<li>Avoids concurrency problems caused by shared mutable state</li>
						<li>Easier to reason about</li>
					</ul>
				</section>
				<section data-background-iframe="https://gcc.godbolt.org/z/iejoxY" data-background-interactive>
				</section>
			</section>
			<section data-transition="convex">
				Thank You!
			</section>
		</div>
	</div>

	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			slideNumber: 'c',
			hash: true,
			highlight: {
				escapeHTML: false,
				tabReplace: '  '
			},
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true },
				// Other plugins
				{ src: 'node_modules/revealjs-animated/dist/revealjs-animated.js', async: true }
			]
		});
	</script>
	<style type="text/css">
		.footer {
			display: grid;
			grid-template-columns: 40% 40% auto;
			position: absolute;
			bottom: 3%;
			justify-content: space-around;
			width: 100%;
			font-size: 50%;
			color: black;
			padding-top: 2px;
			padding-bottom: 2px;
		}
	</style>

	<!-- 2. Create hidden header/footer <div> -->
	<div id="hidden" style="display:none;">
		<div id="header">
			<div class="footer">
				<div>Dvir Yitzchaki, Verizon Media, July 2019</div>
				<div>Introduction to Functional Programming</div>
			</div>
		</div>
	</div>

	<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
	<script type="text/javascript">
		// 3. On Reveal.js ready event, copy header/footer <div> into each `.slide-background` <div>
		var background = $("body").css("background-color")
		var foreground = $(".reveal").css("color")
		$(".footer").css("background-image", `linear-gradient(to right, ${foreground}, ${background})`)
		var header = $('#header').html();
		if (window.location.search.match(/print-pdf/gi)) {
			Reveal.addEventListener('ready', function (event) {
				$('.slide-background').append(header);
			});
		}
		else {
			$('div.reveal').append(header);
		}
	</script>
</body>

</html>